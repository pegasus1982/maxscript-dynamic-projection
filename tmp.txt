-- find intersection
    fn find_intersection node_to_z dir =(
        --matrix = [dir[1],dir[2],dir[3]]
        matrix = [0,0,dir[3]]
        local testRay = ray node_to_z.pos matrix --[0,0,-1]
        local nodeMaxZ = targetMesh.max.z
        testRay.pos.z = nodeMaxZ + 0.0001 * abs nodeMaxZ
        intersectRay targetMesh testRay
    )
    -- end find intersection
    -- drawing points
    fn createSpheresFromArray arr p p_name p_color = (
        if(arr.count > 0) do(
            ID   = arr[1][1]
            minX = arr[1][2]
            minY = arr[1][3]
            maxX = arr[1][2]
            maxY = arr[1][3]
            for i = 2 to arr.count do(
                --format "x : %, y : %\n" arr[i][1] arr[i][2]
                if(minX > arr[i][1]) do(minX = arr[i][2])
                if(minY > arr[i][2]) do(minY = arr[i][3])
                if(maxX < arr[i][1]) do(maxX = arr[i][2])
                if(maxY < arr[i][2]) do(maxY = arr[i][3])
            )
            bounce = spin_Radius.value
            t = 0
            --format "min x : %, max x : %\n" minX maxX
            --format "min y : %, max y : %\n" minY maxY
            centerX = (maxX + minX) / 2
            centerY = (maxY + minY) / 2
            print (maxX-minX)
            print (maxY-minY)
            if((maxX-minX) > (maxY-minY)) then(
                t = bounce / float(maxX-minX)
            )
            else(
                t = bounce / float(maxY-minY)
            )
            format "bounce : %, t : %\n" bounce t
            for i = 1 to arr.count do(
                index = arr[i][1] as string
                tmp_name = p_name+"_"+index
                
                sph = sphere()
                sph.name = tmp_name
                sph.wirecolor = p_color
                sph.radius = 1
                sph.position.x = p[1]-(centerX-arr[i][2])*t
                sph.position.y = p[2]-(centerY-arr[i][3])*t
                sph.position.z = p[3]

                --sph.pivot.x = p[1]
                --sph.pivot.y = p[2]
                --sph.pivot.z = p[3]

                --sph.rotation.x = dir[1]
                --sph.rotation.y = dir[2]
                --sph.rotation.z = dir[3]
                
                mouseray = mapScreenToWorldRay mouse.pos
                dir = mouseray.dir

                sph_project = sphere()
                sph_project.name = tmp_name+"_project"
                sph_project.wirecolor = (color 54 108 207)
                sph_project.radius = 1
                sph_project.position.x = p[1]-(centerX-arr[i][2])*t
                sph_project.position.y = p[2]-(centerY-arr[i][3])*t
                sph_project.position.z = p[3]
                -- find intersection
                int_point = find_intersection sph dir
                if int_point != undefined then sph_project.pos = int_point.pos
            )
        )
    )
    fn drawPoints p btn = (
        btn_Left.checked = false
        btn_Right.checked = false

        if(classOf p == Point3) do(
            if(btn == "left") then(
                delete $*left_point*
                arr = originLeftPointArray
                createSpheresFromArray arr p "left_point" color_pink
            )
            else(
                delete $*right_point*
                arr = originLeftPointArray
                createSpheresFromArray arr p "right_point" color_cyan
            )
        )
    )
    -- end drawing points